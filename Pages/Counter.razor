@page "/counter"

@inherits Fluxor.Blazor.Web.Components.FluxorComponent // This is the base class for all Fluxor components, it provides the Store property

@*  This is the namespace for Fluxor    *@ 
@using Fluxor
@using Fluxor.Undo
@using BlazorWithRedux.Store

@*  
    IState<T> is a Fluxor interface that represents the current state of a feature. 
    In this case, CounterState is likely a class that holds the current state of a counter feature in your application. 
*@
@inject IState<UndoableCounterState> UndoableCounterState
@*
    IDispatcher is a Fluxor interface that provides a way to dispatch actions to the store. 
    You can use it to dispatch actions to the store from your components.
*@
@inject IDispatcher Dispatcher


<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>
<p role="status">Current count: @currentCount</p>
<p>Double count: @doubleCount</p>
<p>Is even: @isEven</p>
<p>Is odd: @isOdd</p>
<p>Is negative: @isNegative</p>
<p>Is positive: @isPositive</p>
<p>Is zero: @isZero</p>

<button class="btn btn-primary" @onclick="IncrementCount">Add +1</button>

<button class="btn btn-primary" @onclick="DecrementCount">Add -1</button>

<button class="btn btn-secondary" @onclick=@(() => Dispatcher.Dispatch(new UndoAllAction<UndoableCounterState>())) disabled="@UndoableCounterState.Value.HasNoPast">&lt;&lt;</button>
<button class="btn btn-secondary" @onclick=@(() => Dispatcher.Dispatch(new UndoAction<UndoableCounterState>())) disabled="@UndoableCounterState.Value.HasNoPast">&lt;</button>
<button class="btn btn-secondary" @onclick=@(() => Dispatcher.Dispatch(new RedoAction<UndoableCounterState>())) disabled="@UndoableCounterState.Value.HasNoFuture">&gt;</button>
<button class="btn btn-secondary" @onclick=@(() => Dispatcher.Dispatch(new RedoAllAction<UndoableCounterState>())) disabled="@UndoableCounterState.Value.HasNoFuture">&gt;&gt;</button>

@code {
    private int currentCount => UndoableCounterState.Value.Present.Count;
    private int doubleCount => UndoableCounterState.Value.Present.DoubleCount;
    private bool isEven => UndoableCounterState.Value.Present.IsEven;
    private bool isOdd => UndoableCounterState.Value.Present.IsOdd;
    private bool isNegative => UndoableCounterState.Value.Present.IsNegative;
    private bool isPositive => UndoableCounterState.Value.Present.IsPositive;
    private bool isZero => UndoableCounterState.Value.Present.IsZero;

    private void IncrementCount()
    {
        Dispatcher.Dispatch(new AddCounter()); 
        // Dispatch the action to the store
    }

    private void DecrementCount()
    {
        Dispatcher.Dispatch(new SubCounter()); 
    }
}
